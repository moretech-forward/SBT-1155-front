<body id="itrf">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link
    href="https://cdn.jsdelivr.net/npm/daisyui@4.10.2/dist/full.min.css"
    rel="stylesheet"
    type="text/css"
  />
  <link
    href="https://cdn.jsdelivr.net/npm/toastify-js/src/toastify.min.css"
    rel="stylesheet"
    type="text/css"
  />

  <link href="./output.css" rel="stylesheet" />

  <p id="future_address" class="hidden invisible"></p>
  <div class="p-2 hidden invisible">
    <div class="accordion">
      <div class="accordion-item">
        <section class="m-auto w-100">
          <h3 id="headingOne" class="accordion-header text-center">
            <button
              type="button"
              data-bs-toggle="collapse"
              data-bs-target="#collapse_myAddr"
              aria-expanded="true"
              aria-controls="collapse_myAddr"
              class="accordion-button collapsed"
            >
              myAddr
            </button>
          </h3>
          <div
            id="collapse_myAddr"
            aria-labelledby="headingOne"
            data-bs-parent="#accordionExample"
            class="accordion-collapse collapse"
          >
            <div class="accordion-body">
              <form id="form-myAddr" class="d-flex flex-column gap-2 p-2">
                <div>
                  <button
                    id="btn"
                    type="button"
                    data-form-name="myAddr"
                    class="btn btn-primary mt-2"
                  >
                    Read
                  </button>
                </div>
                <div>
                  <p>Response:</p>
                  <div>
                    :
                    <span
                      id="form-output-myAddr-0"
                      data-form-name="myAddr"
                      data-field-type="address"
                      >address</span
                    >
                    <br />
                  </div>
                </div>

                <script>
                  setTimeout(() => {
                    const element = document.getElementById("btn");
                    if (element) {
                      element.click();

                      setTimeout(() => {
                        const future_address =
                          document.getElementById("future_address");
                        future_address.innerHTML = document.getElementById(
                          "form-output-myAddr-0"
                        ).innerHTML;
                      }, 1000);
                    }
                  }, 1000);
                </script>
              </form>
            </div>
          </div>
        </section>
      </div>
    </div>
  </div>

  <section
    data-theme="dark"
    id="content"
    class="pt-20 flex items-center flex-col gap-10 min-h-screen bg-base-100 hidden"
  >
    <br />
    <h1 class="text-center text-3xl font-extrabold text-white">
      Soulbound Token (ERC1155)
    </h1>
    <div role="tablist" class="tabs tabs-boxed">
      <a
        role="tab"
        id="nft-tab"
        class="tab tab-active transition-all duration-200"
      >
        All NFT
      </a>
    </div>
    <div
      id="nft-cards"
      class="mx-auto px-[20px] max-w-[1170px] grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-6"
    ></div>
  </section>

  <script
    src="https://cdn.ethers.io/lib/ethers-5.2.umd.min.js"
    type="application/javascript"
  ></script>
  <script
    src="https://cdn.jsdelivr.net/npm/toastify-js"
    type="text/javascript"
  ></script>
  <script src="https://unpkg.com/typed.js@2.1.0/dist/typed.umd.js"></script>

  <script>
    const abi = [
      "constructor(string _name, string _symbol) payable",
      "event OwnershipTransferred(address indexed user, address indexed newOwner)",
      "event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] amounts)",
      "event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 amount)",
      "event URI(string value, uint256 indexed id)",
      "function balanceOf(address, uint256) view returns (uint256)",
      "function balanceOfBatch(address[] owners, uint256[] ids) view returns (uint256[] balances)",
      "function batchBurn(address from, uint256[] tokenIds, uint256[] amounts)",
      "function batchMint(address to, uint256[] tokenIds, uint256[] amounts)",
      "function burn(address from, uint256 tokenId, uint256 amount)",
      "function mint(address to, uint256 tokenId, uint256 amount)",
      "function myAddr() view returns (address)",
      "function name() view returns (string)",
      "function owner() view returns (address)",
      "function setURI(uint256 tokenId, string tokenURI)",
      "function supportsInterface(bytes4 interfaceId) view returns (bool)",
      "function symbol() view returns (string)",
      "function transferOwnership(address newOwner)",
      "function uri(uint256 tokenId) view returns (string)",
    ];

    // const contractAddress = "0x5FbDB2315678afecb367f032d93F642f64180aa3";
    // const privateKey =
    //   "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80";

    let contractAddress;
    const getAddress = async () => {
      contractAddress = document.getElementById("future_address").innerHTML;
    };

    let provider, wallet, contract;

    async function connectToContract() {
      provider = new ethers.providers.Web3Provider(this.parent.ethereum);
      wallet = provider.getSigner();
      contract = new ethers.Contract(contractAddress, abi, wallet);
      // provider = new ethers.providers.JsonRpcProvider();
      // wallet = new ethers.Wallet(privateKey, provider);
      // contract = new ethers.Contract(contractAddress, abi, wallet);
    }

    setTimeout(() => {
      getAddress();
      connectToContract();
    }, 2100);
  </script>

  <script>
    function shortenAddress(address) {
      if (address.length < 10) return address; // Если адрес слишком короткий, возвращаем его как есть
      return address.slice(0, 6) + "..." + address.slice(-5); // Возвращаем сокращенный адрес
    }

    const customCallToast = (msg) => {
      Toastify({
        text: msg,
        position: "center",
        gravity: "top",
      }).showToast();
    };

    let nfts = [];
    let batch_nfts = [];
    const getNfts = async () => {
      const get_nfts = await contract.queryFilter("TransferSingle");
      get_nfts.forEach((nft) => {
        nfts.push(nft.args);
      });

      const batch_events = await contract.queryFilter("TransferBatch");

      batch_events.forEach((nft) => {
        batch_nfts.push(nft.args);
      });
    };

    const renderNfts = async () => {
      const section = document.getElementById("nft-cards");
      section.innerHTML = "";
      // console.log(nfts.length);

      const batch_nftMap = new Map();

      for (let item in batch_nfts) {
        const nft = batch_nfts[item];
        const to = nft[2];
        const ids = nft[3];
        const amounts = nft[4];

        if (to !== "0x0000000000000000000000000000000000000000") {
          for (let index = 0; index < ids.length; index++) {
            const id = ids[index];
            const key = `${id}-${to}`;
            if (!batch_nftMap.has(key)) {
              const balance = (await contract.balanceOf(to, id)).toString();
              if (balance !== "0") {
                // Проверка баланса перед добавлением
                batch_nftMap.set(key, {
                  id: id,
                  to: to,
                  balance: balance,
                });
              }
            }
          }
        }
      }

      // Вывод уникальных NFT
      const batchResults = Array.from(batch_nftMap.values());

      for (let item in nfts) {
        const nft = nfts[item];
        const to = nft[2];
        const id = nft[3];
        const amount = nft[4];

        const balance = (await contract.balanceOf(to, id)).toString();
      }

      const nftMap = new Map();

      // Перебираем начальный массив, фильтруя повторения
      for (const nft of nfts) {
        const key = `${nft.id}-${nft.to}`;
        if (
          !nftMap.has(key) &&
          nft.to !== "0x0000000000000000000000000000000000000000"
        ) {
          const balance = (await contract.balanceOf(nft.to, nft.id)).toString();

          if (balance !== "0") {
            // Проверка баланса перед добавлением
            nftMap.set(key, {
              id: nft.id,
              to: nft.to,
              balance: balance,
            });
          }
        }
      }

      // Преобразуем Map обратно в массив для удобства
      const nftResults = Array.from(nftMap.values());

      // Вывод результатов
      //console.log(results);
      // Создание нового Map для уникализации данных
      const uniqueMap = new Map();

      // Функция для добавления элементов в Map для уникализации
      function addUniqueItems(items) {
        items.forEach((item) => {
          const key = `${item.id}-${item.to}-${item.balance}`; // Создание уникального ключа, включая balance
          if (!uniqueMap.has(key)) {
            uniqueMap.set(key, item);
          }
        });
      }

      // Добавление элементов из обоих массивов
      addUniqueItems(batchResults);
      addUniqueItems(nftResults);

      // Получение уникального массива из Map
      const results = Array.from(uniqueMap.values()).sort((a, b) => {
        return a.id - b.id; // Сортировка по возрастанию id
      });
      //const results = [...batchResults, ...nftResults];

      for (let item in results) {
        const nft = results[item];
        const ownerAddress = nft.to;
        const id = nft.id;
        const amount = nft.balance;

        try {
          const link = await contract.uri(id);
          if (!link.startsWith("http")) {
            customCallToast(`Invalid link for nft with id: ${id}`);
            continue;
          }
          const res = await fetch(link);
          const json = await res.json();

          section.innerHTML += `
                    <div class="card max-w-[320px] bg-base-100 shadow-xl">
                        <figure>
                            <img
                                src="${
                                  json.image
                                    ? json.image
                                    : "https://via.assets.so/img.jpg?w=400&h=300&tc=blue&bg=#cecece"
                                }"
                                alt="Shoes"
                                class="max-h-[250px] w-full object-cover"
                            />
                        </figure>
                        <div class="card-body">
                            <h2 class="card-title">${
                              json.name ? json.name : "Name not defined"
                            }</h2>

                            <div class="flex flex-col gap-2 text-xl font-medium">
                                <div class="flex items-center justify-between w-full">
                                    <p>ID:</p> <p class="text-lg font-normal text-end">${id}</p>
                                </div>
                                <div class="flex items-center justify-between w-full">
                                    <p>Owner:</p> <p class="text-lg font-normal text-end">${shortenAddress(
                                      ownerAddress
                                    )}</p>
                                </div>
                                <div class="flex items-center justify-between w-full">
                                    <p>Amount:</p> <p class="text-lg font-normal text-end">${amount}</p>
                                </div>
                            </div>

                            <p>
                                ${
                                  json.description
                                    ? json.description
                                    : "Description not found"
                                }
                            </p>
                        </div>
                    </div>
                </div>
                `;
        } catch (err) {
          customCallToast(`Failed to withdraw nft with id: ${id}`);
        }
      }
    };

    setTimeout(() => {
      getNfts().then(renderNfts);
    }, 3000);
  </script>
</body>
